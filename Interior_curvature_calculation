import trimesh
import numpy as np
import pandas as pd
from collections import defaultdict
from scipy.stats import zscore
from scipy.ndimage import gaussian_filter1d
import os

# Load Data
os.chdir("facial_research")
reconstructed_faces = pd.read_csv("data/reconstructed_faces.csv").values
n_faces, n_coords = reconstructed_faces.shape
n_vertices = n_coords // 3

# Reshape Data
face_data = reconstructed_faces.reshape(n_faces, n_vertices, 3)

# Define curvature estimation function
def angle_at_vertex(v0, v1, v2):
    a = v1 - v0
    b = v2 - v0
    cos_theta = np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))
    return np.arccos(np.clip(cos_theta, -1.0, 1.0))

def estimate_gaussian_curvature(mesh):
    angle_sum = np.zeros(len(mesh.vertices))
    for face in mesh.faces:
        v0, v1, v2 = mesh.vertices[face]
        a0 = angle_at_vertex(v0, v1, v2)
        a1 = angle_at_vertex(v1, v2, v0)
        a2 = angle_at_vertex(v2, v0, v1)
        angle_sum[face[0]] += a0
        angle_sum[face[1]] += a1
        angle_sum[face[2]] += a2
    return 2 * np.pi - angle_sum


folder = '5pc_simfaces'

# Figure out the interior vertices from the first face
filename = "simface_5pc_1.obj"
filepath = os.path.join(folder, filename)
mesh = trimesh.load(filepath)

# Identify boundary vertices
edge_face_count = defaultdict(int)
for face in mesh.faces:
    edges = [tuple(sorted([face[j], face[(j + 1) % 3]])) for j in range(3)]
    for edge in edges:
        edge_face_count[edge] += 1
boundary_edges = np.array([edge for edge, count in edge_face_count.items() if count == 1])
boundary_vertices = np.unique(boundary_edges)

# Mask
interior_mask = np.ones(n_vertices, dtype=bool)
interior_mask[boundary_vertices] = False

# Container for curvature values
n_interior = np.sum(interior_mask)
all_curvatures = np.zeros((n_faces, n_interior))


# Process each face
for i in range(1, n_faces+1):  # Adjust range as needed
    filename = f"simface_5pc_{i}.obj"
    filepath = os.path.join(folder, filename)
    mesh = trimesh.load(filepath)
    # Estimate curvature
    curvatures = estimate_gaussian_curvature(mesh)
    
    # Mask and normalize curvature
    interior_curvatures = np.exp(curvatures[interior_mask])
    z = zscore(interior_curvatures)
    
    z = np.clip(z, -2, 2)  # clip extremes
    norm_curv = (z - z.min()) / (z.ptp() + 1e-8)

    # Store normalized curvatures
    all_curvatures[i-1] = norm_curv

np.save("processed/interior_curvatures_good.npy", all_curvatures)
# np.save("processed/interior_mask.npy", interior_mask)